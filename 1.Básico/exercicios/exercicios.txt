## Exercícios 
### Exercícios Gerais
1. Manipulação de Registradores
Troca de Valores
    Carregue 15 em $t0 e 25 em $t1. Troque os valores entre $t0 e $t1 sem usar registradores adicionais (dica: use operações aritméticas).
**DUVIDA**

Uso do $zero
    Carregue 100 em $s0. Use $zero para:
    Mover o valor de $s0 para $s1
    RESPOSTA: troca_valores.asm (CORRETO!)

2. Operações Aritméticas
Cálculo com Constantes
    Calcule (37 - 15) * 2 usando apenas:

    addi para constantes

    sub para subtração

    mul para multiplicação
    Armazene o resultado em $t2 e imprima.
    
    RESPOSTA: operacoes_aritmeticas.asm(CORRETO!)

Divisão com Resto
    Leia um número do usuário em $t0. Calcule:

    Quociente da divisão por 3 (armazene em $t1)

    Resto da divisão (armazene em $t2)
    Imprima ambos usando div e mfhi/mflo.

    RESPOSTA: divisao_resto.asm(CORRETO!)

3. Condicionais Básicas
    Positivo/Negativo
    Leia um número do usuário:

    Se for positivo, imprima "POSITIVO"

    Se negativo, imprima "NEGATIVO"

    Se zero, imprima "ZERO"
    Use slt e beq/bne.
    RESPOSTA: positivo_negativo.asm(CORRETO!)

Comparação Dupla
    Leia dois números A e B:

    Se A > B, imprima "MAIOR"

    Se A < B, imprima "MENOR"

    Se iguais, imprima "IGUAIS"
    Use apenas slt + branches.
    RESPOSTA: compara_inteiros.asm(CORRETO!)

4. Loops Simples
Contagem Regressiva
    Imprima números de 10 a 1 em ordem decrescente:

    Use $t0 como contador

    Decremente com addi

    Termine quando $t0 = 0
    RESPOSTA: contagem_regressiva.asm(CORRETO!)

Soma de Pares
    Some os números pares de 2 a 20:

    Use $t0 como acumulador

    Incremente de 2 em 2 com addi

    Use ble para controlar o loop
    RESULTADO: soma_pares.asm(CORRETO!)

5. Funções Simples
    Dobro de um Número
    Crie uma função dobro que:

    Recebe argumento em $a0

    Retorna o dobro em $v0

    Chame com jal passando 7
    Imprima o resultado.
    RESULTADO: funcao_dobro.asm(CORRETO!)

Verificação de Paridade
    Implemente uma função par que:

    Recebe número em $a0

    Retorna 1 em $v0 se par, 0 se ímpar

    Use andi $t0, $a0, 1 (bit menos significativo)
    Teste com números 9 e 12.
    RESULTADO: funcao_par_impar.asm(CORRETO!)

6. Desafios Práticos
Múltiplo de 5
    Leia um número e verifique se é múltiplo de 5:

    Use div e verifique se resto = 0

    Imprima "SIM" ou "NAO"
    RESPOSTA: multiplo5.asm

Potência de 2
    Leia um número n (1 ≤ n ≤ 10):

    Calcule 2^n usando loop com multiplicações

    Armazene resultado em $s0

    Exemplo: n=5 → 32
    RESULTADO: potencia2.asm

EXERCÍCIOS EM SALA 

(1)Fazer um programa em assembly MIPS que imprima em binário uma palavra de 32 bits armazenada na memória.  

Por exemplo, o conteúdo de memória no endereço determinado pelo rótulo variavel abaixo

variavel: .word 0x8000000f
deverá ser impresso como 

1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 


EXERCÍCIOS DE REVISÃO
Exercício 1: Função Fatorial com Loop
Escreva uma função chamada fatorial que recebe um número inteiro não negativo n (passado via registrador $a0) e calcula o seu fatorial (n!) usando um loop. A função deve retornar o resultado no registrador $v0. O programa principal deve chamar essa função com um valor específico (ex: 5) e armazenar o resultado na memória. Use apenas multiplicações que podem ser tratadas com mul (considere que o resultado será < 2³¹).

Exercício 2: Somatório de uma Série Aritmética
Implemente uma função chamada soma_serie que calcula a soma dos primeiros N termos de uma série. A função deve receber em $a0 o valor de N (número de termos) e em $a1 o valor inicial da série. Cada termo é calculado como (valor_inicial + i) * 2, onde i é o índice do termo (0 a N-1). Use um loop para calcular o somatório e retorne o resultado em $v0. O programa principal deve chamar a função com N=5 e valor_inicial=3, armazenando o resultado.

Exercício 3: Função de Potência com Manipulação de HI/LO
Crie uma função potencia que recebe uma base inteira em $a0 e um expoente inteiro não negativo em $a1. A função deve calcular a base elevada ao expoente usando um loop e multiplicações sucessivas. Como o resultado pode ser grande, use mult (em vez de mul) e retorne o valor de 32 bits menos significativo em $v0 (usando mflo). O programa principal deve testar a função com base=2 e expoente=10, verificando se o resultado correto (1024) é retornado.

